<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æœ¬åœ°åŒäººé£è¡Œæ£‹ï¼ˆCSVæ£‹ç›˜ï¼‰</title>
  <style>
    :root{--cell-size:64px;--gap:6px}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:12px;background:#f6f7f9;color:#111}
    h1{font-size:18px;margin:6px 0}
    .top{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .controls{display:flex;gap:8px;align-items:center}
    button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:white;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    input[type=file]{display:block}
    .board-wrap{margin-top:12px;display:flex;gap:12px}
    .board{background:#ddd;padding:12px;border-radius:12px;display:inline-grid;grid-gap:var(--gap);align-content:start}
    .cell{width:var(--cell-size);height:var(--cell-size);display:flex;flex-direction:column;justify-content:center;align-items:center;font-size:12px;border-radius:6px;position:relative;border:1px solid rgba(0,0,0,.08)}
    .cell .idx{position:absolute;left:4px;top:4px;font-size:11px;opacity:.9}
    .cell .content{font-size:12px;text-align:center;padding:6px;word-break:break-word}
    .cell.arrow::after{content:"";position:absolute;right:4px;bottom:4px;width:0;height:0;border:6px solid transparent}
    /* arrow by direction */
    .dir-right.arrow::after{border-left-color:rgba(0,0,0,.18)}
    .dir-down.arrow::after{border-top-color:rgba(0,0,0,.18)}
    .dir-left.arrow::after{border-right-color:rgba(0,0,0,.18)}
    .dir-up.arrow::after{border-bottom-color:rgba(0,0,0,.18)}

    .legend{display:flex;gap:8px;align-items:center;margin-top:8px}
    .legend .sw{width:16px;height:16px;border-radius:3px;border:1px solid #aaa}

    .info{min-width:220px}
    .players{display:flex;flex-direction:column;gap:6px}
    .player{display:flex;align-items:center;gap:8px}
    .piece{width:20px;height:20px;border-radius:50%;box-shadow:0 1px 0 rgba(0,0,0,.15)}
    .log{background:#fff;border:1px solid #e0e0e0;padding:8px;border-radius:8px;height:240px;overflow:auto;font-size:13px}

    .modal{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.45)}
    .modal .card{background:#fff;padding:16px;border-radius:10px;min-width:320px;max-width:90%;box-shadow:0 8px 32px rgba(0,0,0,.25)}
    .meta{font-size:12px;color:#666;margin-top:8px}
    .hidden{display:none}

    /* players positions inside cell */
    .pos{position:absolute;bottom:4px;left:4px;display:flex;gap:4px}
    .pos .p{width:14px;height:14px;border-radius:50%;border:2px solid #fff}

    /* colors for cell types */
    .cell.start{background:gold}
    .cell.end{background:gold}
    .cell.bonus{background:#cfe8ff}
    .cell.penalty{background:#ffd8d8}
    .cell.normal{background:#fff}

    /* small responsive */
    @media (max-width:900px){:root{--cell-size:48px}}
  </style>
</head>
<body>
  <h1>æœ¬åœ°åŒäººé£è¡Œæ£‹ï¼ˆCSVæ£‹ç›˜ï¼‰</h1>
  <div class="top">
    <div class="controls">
      <label>å¯¼å…¥æ£‹ç›˜ CSVï¼ˆ56 è¡Œï¼‰ï¼š<input id="csvfile" type="file" accept="text/csv,text/plain" /></label>
      <button id="rollBtn" disabled>æŠ•éª°å­ ğŸ²</button>
      <button id="skipBtn" disabled>è·³è¿‡å›åˆ</button>
      <button id="resetBtn">é‡ç½®</button>
    </div>
    <div class="info">
      <div class="players">
        <div class="player"><strong id="turn">å½“å‰ï¼š-</strong></div>
        <div class="player">éª°å­ç»“æœï¼š<span id="dice">-</span></div>
      </div>
    </div>
  </div>

  <div style="margin-top:8px;display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap">
    <div class="board-wrap">
      <div id="board" class="board"></div>
    </div>
    <div style="min-width:260px">
      <div style="display:flex;gap:8px;align-items:center">
        <div style="display:flex;gap:6px;align-items:center">
          <div class="sw" style="background:gold"></div><span style="font-size:13px">start/end</span>
        </div>
        <div style="display:flex;gap:6px;align-items:center">
          <div class="sw" style="background:#cfe8ff"></div><span style="font-size:13px">bonus</span>
        </div>
        <div style="display:flex;gap:6px;align-items:center">
          <div class="sw" style="background:#ffd8d8"></div><span style="font-size:13px">penalty</span>
        </div>
      </div>
      <div style="margin-top:8px">
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

  <!-- modal -->
  <div id="modal" class="modal hidden" tabindex="0">
    <div class="card">
      <h3 id="m-title"></h3>
      <div id="m-detail"></div>
      <div class="meta">ç±»å‹: <span id="m-type"></span> å‚æ•°: <span id="m-param"></span></div>
      <div style="margin-top:12px;text-align:right">
        <button id="m-continue">ç»§ç»­ï¼ˆEnterï¼‰</button>
      </div>
    </div>
  </div>

  <script>
    /*
      è¯´æ˜:
      - å›ºå®šä½¿ç”¨ 7 è¡Œ x 8 åˆ— çš„çŸ©å½¢å¸ƒå±€ï¼Œå…± 56 æ ¼ï¼ˆæ»¡è¶³é¢˜ç›®è¦æ±‚ï¼‰ã€‚
      - CSV å¿…é¡»æœ‰ 56 è¡Œï¼Œæ¯è¡Œ4åˆ—ï¼šå†…å®¹, è¯¦æƒ…, ç±»å‹, å‚æ•°(å¯é€‰)ã€‚
      - ç±»å‹ï¼šstart, end, normal, bonus, penalty
      - ä¸¤ä¸ªç©å®¶å‡ä»ç¬¬ä¸€ä¸ªé‡åˆ°çš„ start æ ¼å¼€å§‹ã€‚
      - ç©å®¶1 çº¢å­ï¼Œç©å®¶2 è“å­ã€‚ç©å®¶1å…ˆè¡Œã€‚
    */

    const ROWS = 7, COLS = 8, TOTAL = ROWS*COLS; // TOTAL must be 56
    const boardEl = document.getElementById('board');
    const fileInput = document.getElementById('csvfile');
    const rollBtn = document.getElementById('rollBtn');
    const skipBtn = document.getElementById('skipBtn');
    const resetBtn = document.getElementById('resetBtn');
    const logEl = document.getElementById('log');
    const turnEl = document.getElementById('turn');
    const diceEl = document.getElementById('dice');
    const modal = document.getElementById('modal');
    const mTitle = document.getElementById('m-title');
    const mDetail = document.getElementById('m-detail');
    const mType = document.getElementById('m-type');
    const mParam = document.getElementById('m-param');
    const mContinue = document.getElementById('m-continue');

    let cells = []; // array of {content,detail,type,param,index,row,col,dir}
    let players = [ {name:'ç©å®¶1', color:'red', pos:null}, {name:'ç©å®¶2', color:'blue', pos:null} ];
    let current = 0; // 0 -> player1
    let gameLoaded = false;
    let moving = false;
    let modalResolve = null;

    // build empty grid layout (will be filled after CSV loaded)
    function buildGrid() {
      boardEl.style.gridTemplateColumns = `repeat(${COLS}, ${getComputedStyle(document.documentElement).getPropertyValue('--cell-size') || '64px'})`;
      boardEl.innerHTML = '';
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          const d = document.createElement('div');
          d.className = 'cell normal';
          d.innerHTML = `<div class="idx"></div><div class="content"></div><div class="pos"></div>`;
          boardEl.appendChild(d);
        }
      }
    }

    // generate spiral indices starting top-left going right, down, left, up
    function generateSpiralPositions(rows, cols){
      const grid = Array.from({length:rows},()=>Array(cols).fill(null));
      const res = [];
      let top=0, left=0, right=cols-1, bottom=rows-1;
      while(left<=right && top<=bottom){
        for(let c=left;c<=right;c++) res.push([top,c]);
        top++;
        for(let r=top;r<=bottom;r++) res.push([r,right]);
        right--;
        if(top<=bottom){
          for(let c=right;c>=left;c--) res.push([bottom,c]);
          bottom--;
        }
        if(left<=right){
          for(let r=bottom;r>=top;r--) res.push([r,left]);
          left++;
        }
      }
      return res; // length should equal rows*cols
    }

    const spiral = generateSpiralPositions(ROWS,COLS);

    function parseCSV(text){
      // basic CSV parser: split lines, then split by comma not inside quotes
      const lines = text.split(/\r?\n/).filter(l=>l.trim()!=='');
      const rows = lines.map(line=>{
        const cols = [];
        let cur=''; let inQ=false;
        for(let i=0;i<line.length;i++){
          const ch=line[i];
          if(ch==='"') { inQ=!inQ; continue; }
          if(ch===',' && !inQ){ cols.push(cur); cur=''; } else cur+=ch;
        }
        cols.push(cur);
        return cols.map(s=>s.trim());
      });
      return rows;
    }

    function loadFromCSVText(text){
      const rows = parseCSV(text);
      if(rows.length!==TOTAL){ alert(`CSV è¡Œæ•°å¿…é¡»ä¸º ${TOTAL} è¡Œï¼Œå½“å‰ ${rows.length} è¡Œ`); return; }
      cells = new Array(TOTAL);
      for(let i=0;i<TOTAL;i++){
        const [content, detail, type, param] = rows[i].concat(['','','','']);
        const pos = spiral[i];
        const index = i+1;
        cells[i] = {content:content||'', detail:detail||'', type:(type||'normal').toLowerCase(), param: param?Number(param):0, index, row:pos[0], col:pos[1], dir:null };
      }
      // assign direction arrows based on next cell
      for(let i=0;i<TOTAL;i++){
        const cur = cells[i];
        if(i===TOTAL-1){ cur.dir = null; } else {
          const nx = cells[i+1];
          if(nx.row === cur.row && nx.col === cur.col+1) cur.dir='right';
          else if(nx.row === cur.row+1 && nx.col === cur.col) cur.dir='down';
          else if(nx.row === cur.row && nx.col === cur.col-1) cur.dir='left';
          else if(nx.row === cur.row-1 && nx.col === cur.col) cur.dir='up';
          else cur.dir=null;
        }
      }

      // map cells into grid DOM
      const cellEls = boardEl.querySelectorAll('.cell');
      // build mapping from (r,c) to element index
      const gridIdx = {}; // key r,c -> el
      let idx=0;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          gridIdx[`${r},${c}`] = idx++;
        }
      }
      // clear
      cellEls.forEach(el=>{
        el.className='cell normal';
        el.querySelector('.idx').textContent='';
        el.querySelector('.content').textContent='';
        el.querySelector('.pos').innerHTML='';
      });

      cells.forEach((cell,i)=>{
        const el = cellEls[ gridIdx[ `${cell.row},${cell.col}` ] ];
        el.querySelector('.idx').textContent = cell.index;
        el.querySelector('.content').textContent = cell.content;
        el.classList.remove('normal','start','end','bonus','penalty');
        const t = cell.type;
        if(t==='start') el.classList.add('start');
        else if(t==='end') el.classList.add('end');
        else if(t==='bonus') el.classList.add('bonus');
        else if(t==='penalty') el.classList.add('penalty');
        else el.classList.add('normal');
        // arrow
        el.classList.remove('arrow','dir-right','dir-left','dir-up','dir-down');
        if(cell.dir){ el.classList.add('arrow'); el.classList.add('dir-'+cell.dir); }
      });

      // find first start
      const startIdx = cells.findIndex(c=>c.type==='start');
      if(startIdx===-1){ alert('CSV ä¸­æœªæ‰¾åˆ° start ç±»å‹çš„æ ¼å­ï¼Œè¯·è‡³å°‘æœ‰ä¸€ä¸ª startã€‚'); return; }
      players[0].pos = startIdx; players[1].pos = startIdx; // both start here
      gameLoaded = true;
      current = 0;
      updatePieces();
      logEl.innerHTML='';
      log(`æ£‹ç›˜åŠ è½½å®Œæ¯•ã€‚èµ·å§‹æ ¼: ${startIdx+1}`);
      rollBtn.disabled = false; skipBtn.disabled = false;
      updateTurnDisplay();
    }

    fileInput.addEventListener('change', ()=>{
      const f = fileInput.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = e=> loadFromCSVText(e.target.result);
      reader.readAsText(f,'utf-8');
    });

    function updatePieces(){
      // clear pos
      boardEl.querySelectorAll('.cell .pos').forEach(p=>p.innerHTML='');
      const cellEls = boardEl.querySelectorAll('.cell');
      players.forEach((pl,pi)=>{
        if(pl.pos==null) return;
        const el = cellEls[ getCellElementIndexByCellIndex(pl.pos) ];
        const pos = el.querySelector('.pos');
        const div = document.createElement('div'); div.className='p'; div.style.background=pl.color; pos.appendChild(div);
      });
    }

    function getCellElementIndexByCellIndex(cellIdxZeroBased){
      // cellIdxZeroBased corresponds to cells array index, map to DOM grid index
      const c = cells[cellIdxZeroBased];
      return c.row * COLS + c.col;
    }

    function log(msg){
      const time = new Date().toLocaleTimeString();
      logEl.innerHTML = `<div>[${time}] ${escapeHtml(msg)}</div>` + logEl.innerHTML;
    }

    function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function updateTurnDisplay(){
      turnEl.textContent = `å½“å‰: ${players[current].name}`;
    }

    rollBtn.addEventListener('click', async ()=>{
      if(!gameLoaded || moving) return;
      const roll = Math.floor(Math.random()*6)+1;
      diceEl.textContent = roll;
      log(`${players[current].name} æŠ•éª°å­ï¼Œç»“æœ ${roll}`);
      await movePlayer(current, roll);
      if(!moving) { // after done
        current = (current+1)%2;
        updateTurnDisplay();
      }
    });

    skipBtn.addEventListener('click', ()=>{
      if(!gameLoaded || moving) return;
      log(`${players[current].name} è·³è¿‡æœ¬å›åˆ`);
      current = (current+1)%2; updateTurnDisplay();
    });

    resetBtn.addEventListener('click', ()=>{
      if(!confirm('ç¡®è®¤é‡ç½®æ¸¸æˆå—ï¼Ÿï¼ˆä¼šæ¸…é™¤å½“å‰æ£‹ç›˜ï¼‰')) return;
      // reset
      fileInput.value = '';
      buildGrid();
      cells = [];
      players = [ {name:'ç©å®¶1', color:'red', pos:null}, {name:'ç©å®¶2', color:'blue', pos:null} ];
      gameLoaded=false; rollBtn.disabled=true; skipBtn.disabled=true; diceEl.textContent='-'; logEl.innerHTML=''; turnEl.textContent='å½“å‰ï¼š-';
    });

    // move with step animation
    async function movePlayer(playerIdx, steps){
      moving = true; rollBtn.disabled = true; skipBtn.disabled = true;
      let p = players[playerIdx];
      for(let s=0;s<steps;s++){
        const target = Math.min((p.pos==null?0:p.pos)+1, cells.length-1);
        if(p.pos==null) p.pos = 0; else p.pos = Math.min(p.pos+1, cells.length-1);
        updatePieces();
        await sleep(220);
        // if reached end cell, break
        if(cells[p.pos].type==='end'){ break; }
      }

      // show landed cell modal and process chain of special cells
      await showCellChain(playerIdx, p.pos);

      // check end
      if(cells[players[playerIdx].pos].type==='end'){
        log(`${players[playerIdx].name} åˆ°è¾¾ç»ˆç‚¹ï¼Œè·èƒœï¼`);
        alert(`${players[playerIdx].name} è·èƒœï¼`);
        rollBtn.disabled = true; skipBtn.disabled = true; moving=false; return;
      }

      moving=false; rollBtn.disabled=false; skipBtn.disabled=false;
    }

    async function showCellChain(playerIdx, startPos){
      let pos = players[playerIdx].pos;
      // show current cell first
      await showModalForCell(pos);
      // if special, apply param then show new cell until non-special or no move
      while(true){
        const cell = cells[pos];
        if(cell.type==='bonus' && cell.param && cell.param!==0){
          log(`${players[playerIdx].name} åœ¨ bonus æ ¼ï¼ˆ${cell.index}ï¼‰ï¼Œå‰è¿› ${cell.param} æ ¼`);
          // move step by step
          for(let k=0;k<cell.param;k++){
            players[playerIdx].pos = Math.min(players[playerIdx].pos+1, cells.length-1);
            updatePieces(); await sleep(180);
          }
          pos = players[playerIdx].pos;
          await showModalForCell(pos);
        } else if(cell.type==='penalty' && cell.param && cell.param!==0){
          log(`${players[playerIdx].name} åœ¨ penalty æ ¼ï¼ˆ${cell.index}ï¼‰ï¼Œåé€€ ${cell.param} æ ¼`);
          for(let k=0;k<cell.param;k++){
            players[playerIdx].pos = Math.max(players[playerIdx].pos-1, 0);
            updatePieces(); await sleep(180);
          }
          pos = players[playerIdx].pos;
          await showModalForCell(pos);
        } else {
          break;
        }
        // check end after each chain
        if(cells[pos].type==='end') break;
      }
    }

    function showModalForCell(cellIndexZeroBased){
      const cell = cells[cellIndexZeroBased];
      return new Promise(resolve=>{
        mTitle.textContent = cell.content || `æ ¼å­ ${cell.index}`;
        mDetail.textContent = cell.detail || '(æ— è¯¦æƒ…)';
        mType.textContent = cell.type;
        mParam.textContent = cell.param || '';
        modal.classList.remove('hidden');
        modal.focus();
        modalResolve = ()=>{ modal.classList.add('hidden'); modalResolve = null; resolve(); };
      });
    }

    mContinue.addEventListener('click', ()=>{ if(modalResolve) modalResolve(); });
    document.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && modalResolve){ modalResolve(); } });

    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    // initial
    buildGrid();
    updateTurnDisplay();

    // helper: if user opens HTML on github pages, they need to load a CSV. provide sample download link? We'll offer a sample CSV generator button.
    // create a sample CSV for user to download
    function generateSampleCSV(){
      const lines = [];
      for(let i=1;i<=TOTAL;i++){
        let type='normal', content=`æ ¼ ${i}`, detail=`è¯¦ç»† ${i}`, param='';
        if(i===1){ type='start'; content='Start'; detail='èµ·ç‚¹'; }
        if(i===TOTAL){ type='end'; content='End'; detail='ç»ˆç‚¹'; }
        if(i===6||i===12){ type='bonus'; param=2; }
        if(i===9||i===20){ type='penalty'; param=2; }
        lines.push([content, detail, type, param].join(','));
      }
      return lines.join('\n');
    }

    // add sample download link
    const sampleBtn = document.createElement('button'); sampleBtn.textContent='ä¸‹è½½ç¤ºä¾‹ CSV';
    sampleBtn.addEventListener('click', ()=>{
      const blob = new Blob([generateSampleCSV()],{type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='sample_board.csv'; a.click(); URL.revokeObjectURL(url);
    });
    document.querySelector('.controls').appendChild(sampleBtn);
  </script>
</body>
</html>
