<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>本地双人飞行棋</title>
<style>
  body { margin: 0; font-family: sans-serif; display: flex; height: 100vh; }
  #board-container { flex: 1; display: flex; justify-content: center; align-items: center; }
  #board { display: grid; border: 2px solid #000; width: 90vmin; height: 90vmin; }
  .cell {
    border: 1px solid #555;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    font-size: 0.8em;
    text-align: center;
    padding: 2px;
  }
  .cell span.number { position: absolute; top: 2px; left: 2px; font-size: 0.7em; }
  .arrow { position: absolute; bottom: 2px; right: 2px; font-size: 0.8em; }
  .player { width: 20px; height: 20px; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
  #sidebar { width: 300px; border-left: 2px solid #000; padding: 10px; box-sizing: border-box; display: flex; flex-direction: column; }
  button { margin: 5px 0; padding: 10px; font-size: 1em; cursor: pointer; }
  #log { flex: 1; overflow-y: auto; border: 1px solid #aaa; padding: 5px; margin-top: 5px; background: #f9f9f9; }
  #log p { margin: 2px 0; }
</style>
</head>
<body>

<div id="board-container">
  <div id="board"></div>
</div>

<div id="sidebar">
  <input type="file" id="csvInput" accept=".csv">
  <button id="rollBtn" disabled>投骰子</button>
  <button id="skipBtn" disabled>跳过回合</button>
  <button id="resetBtn">重置</button>
  <div>
    <p>当前玩家: <span id="currentPlayer">-</span></p>
    <p>骰子点数: <span id="diceResult">-</span></p>
  </div>
  <div id="log"></div>
</div>

<script>
let boardData = [];
let cells = [];
let boardSize = 7;
let players = [
  { name: '玩家1', color: 'pink', position: 0 },
  { name: '玩家2', color: 'blue', position: 0 }
];
let currentPlayerIndex = 0;
let animating = false;

// CSV导入
document.getElementById('csvInput').addEventListener('change', function(e){
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    const lines = evt.target.result.trim().split('\n');
    boardData = lines.map(l=>{
      const [content, detail, type, param] = l.split(',');
      return { content, detail, type, param: param ? parseInt(param) : 0 };
    });
    if(boardData.length !== boardSize*boardSize) { alert('CSV必须49格'); return; }
    buildBoard();
    resetGame();
  };
  reader.readAsText(file);
});

// 构建棋盘
function buildBoard(){
  const board = document.getElementById('board');
  board.innerHTML = '';
  board.style.gridTemplateColumns = `repeat(${boardSize},1fr)`;
  cells = [];

  const spiralCoords = getSpiralCoords(boardSize);

  for(let i=0;i<boardData.length;i++){
    const [r,c] = spiralCoords[i];
    const cellDiv = document.createElement('div');
    cellDiv.classList.add('cell');
    const data = boardData[i];
    cellDiv.dataset.index = i;
    cellDiv.style.background = getCellColor(data.type);
    cellDiv.style.gridRowStart = r+1;
    cellDiv.style.gridColumnStart = c+1;
    cellDiv.innerHTML = `<span class="number">${i+1}</span>${data.content}<span class="arrow">${getArrow(i,spiralCoords)}</span>`;
    board.appendChild(cellDiv);
    cells.push(cellDiv);
  }
}

// 获取螺旋坐标
function getSpiralCoords(n){
  let coords = Array(boardSize*boardSize);
  let top=0,bottom=n-1,left=0,right=n-1;
  let idx=0;
  while(top<=bottom && left<=right){
    for(let j=left;j<=right;j++) coords[idx++] = [top,j];
    top++;
    for(let i=top;i<=bottom;i++) coords[idx++] = [i,right];
    right--;
    if(top<=bottom){ for(let j=right;j>=left;j--) coords[idx++] = [bottom,j]; bottom--; }
    if(left<=right){ for(let i=bottom;i>=top;i--) coords[idx++] = [i,left]; left++; }
  }
  return coords;
}

// 箭头方向
function getArrow(index,coords){
  const pos = index;
  if(pos<coords.length-1){
    const [x1,y1] = coords[pos];
    const [x2,y2] = coords[pos+1];
    if(x2>x1) return '↓';
    if(x2<x1) return '↑';
    if(y2>y1) return '→';
    if(y2<y1) return '←';
  }
  return '';
}

function getCellColor(type){
  switch(type){
    case 'start': return 'yellow';
    case 'end': return 'yellow';
    case 'bonus': return 'green';
    case 'penalty': return 'orange';
    case 'wait': return 'purple';
    default: return 'white';
  }
}

// 重置
function resetGame(){
  players.forEach(p=>p.position = 0);
  currentPlayerIndex = 0;
  updateBoard();
  document.getElementById('currentPlayer').textContent = players[currentPlayerIndex].name;
  document.getElementById('diceResult').textContent = '-';
  document.getElementById('rollBtn').disabled = false;
  document.getElementById('skipBtn').disabled = false;
  document.getElementById('log').innerHTML = '';
}

// 更新棋盘显示
function updateBoard(){
  cells.forEach(c=>{
    c.querySelectorAll('.player').forEach(p=>p.remove());
  });
  players.forEach((p,i)=>{
    const cell = cells[p.position];
    const pDiv = document.createElement('div');
    pDiv.classList.add('player');
    pDiv.style.background = p.color;
    cell.appendChild(pDiv);
  });
}

// 日志
function log(msg){
  const logDiv = document.getElementById('log');
  const p = document.createElement('p');
  p.textContent = msg;
  logDiv.appendChild(p);
  logDiv.scrollTop = logDiv.scrollHeight;
}

// 投骰子
document.getElementById('rollBtn').addEventListener('click',()=>{
  if(animating) return;
  const dice = Math.floor(Math.random()*6)+1;
  document.getElementById('diceResult').textContent = dice;
  movePlayer(players[currentPlayerIndex], dice);
});

// 跳过
document.getElementById('skipBtn').addEventListener('click',()=>{
  if(animating) return;
  log(`${players[currentPlayerIndex].name}跳过回合`);
  nextPlayer();
});

// 重置
document.getElementById('resetBtn').addEventListener('click',resetGame);

async function movePlayer(player, steps){
  animating = true;
  for(let i=0;i<steps;i++){
    await moveOneStep(player,1);
  }
  await handleCell(player);
  animating = false;
  nextPlayer();
}

function nextPlayer(){
  currentPlayerIndex = 1 - currentPlayerIndex;
  document.getElementById('currentPlayer').textContent = players[currentPlayerIndex].name;
  document.getElementById('diceResult').textContent = '-';
}

function moveOneStep(player, step){
  return new Promise(resolve=>{
    let target = player.position + step;
    if(target<0) target=0;
    if(target>=boardSize*boardSize) target = boardSize*boardSize-1;
    player.position = target;
    updateBoard();
    setTimeout(resolve,400);
  });
}

function handleCell(player){
  return new Promise(async resolve=>{
    let idx = player.position;
    let cellData = boardData[idx];
    await showCellPopup(player,cellData);
    if(cellData.type==='bonus' && cellData.param>0){
      log(`${player.name}触发bonus，前进${cellData.param}格`);
      for(let i=0;i<cellData.param;i++){
        await moveOneStep(player,1);
      }
      idx = player.position;
      await showCellPopup(player,boardData[idx]);
    } else if(cellData.type==='penalty' && cellData.param>0){
      log(`${player.name}触发penalty，后退${cellData.param}格`);
      for(let i=0;i<cellData.param;i++){
        await moveOneStep(player,-1);
      }
      idx = player.position;
      await showCellPopup(player,boardData[idx]);
    }
    if(cellData.type==='end'){
      alert(`${player.name}胜利！游戏结束`);
      document.getElementById('rollBtn').disabled = true;
      document.getElementById('skipBtn').disabled = true;
    }
    resolve();
  });
}

function showCellPopup(player, cellData){
  return new Promise(resolve=>{
    const msg = `${cellData.content}\n\n详情: ${cellData.detail}\n类型: ${cellData.type}${cellData.param ? ', 参数: '+cellData.param : ''}`;
    alert(msg);
    log(`${player.name}走到格子${player.position+1}: ${cellData.content}`);
    resolve();
  });
}

// 回车继续快捷键
document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){ e.preventDefault(); }
});
</script>

</body>
</html>
